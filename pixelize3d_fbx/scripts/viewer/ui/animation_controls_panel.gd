# scripts/viewer/ui/animation_controls_panel.gd
# Panel COMPATIBLE con viewer_coordinator.gd y con cambios de animaci√≥n funcionando
# Input: Modelo con AnimationPlayer desde populate_animations()
# Output: Se√±ales que espera el coordinator + control funcional de animaciones

extends HBoxContainer

# Se√±ales que espera el viewer_coordinator.gd
signal animation_selected(animation_name: String)
signal play_requested(animation_name: String) 
signal pause_requested()
signal stop_requested()
signal timeline_changed(position: float)

# UI elements
var animations_option: OptionButton
var play_button: Button
var pause_button: Button
var stop_button: Button
var timeline_slider: HSlider
var time_label: Label

# Estado interno
var available_animations: Array = []
var current_animation_player: AnimationPlayer = null
var is_playing: bool = false
var current_animation: String = ""

# Cargar managers
var loop_manager = preload("res://scripts/core/animation_loop_manager.gd")

func _ready():
	_create_ui()
	print("üéÆ AnimationControlsPanel inicializado (Compatible)")

func _create_ui():
	# Label
	var anim_label = Label.new()
	anim_label.text = "Animaci√≥n:"
	add_child(anim_label)
	
	# Dropdown de animaciones
	animations_option = OptionButton.new()
	animations_option.custom_minimum_size.x = 150
	animations_option.add_item("-- No hay animaciones --")
	animations_option.disabled = true
	# CONEXI√ìN CR√çTICA: Conectar item_selected al manejador correcto
	animations_option.item_selected.connect(_on_animation_selected)
	add_child(animations_option)
	
	add_child(VSeparator.new())
	
	# Botones de control
	play_button = Button.new()
	play_button.text = "‚ñ∂Ô∏è"
	play_button.tooltip_text = "Reproducir"
	play_button.disabled = true
	play_button.pressed.connect(_on_play_pressed)
	add_child(play_button)
	
	pause_button = Button.new()
	pause_button.text = "‚è∏Ô∏è"
	pause_button.tooltip_text = "Pausar"
	pause_button.disabled = true
	pause_button.pressed.connect(_on_pause_pressed)
	add_child(pause_button)
	
	stop_button = Button.new()
	stop_button.text = "‚èπÔ∏è"
	stop_button.tooltip_text = "Detener"
	stop_button.disabled = true
	stop_button.pressed.connect(_on_stop_pressed)
	add_child(stop_button)
	
	add_child(VSeparator.new())
	
	# Timeline slider
	var timeline_label = Label.new()
	timeline_label.text = "Timeline:"
	add_child(timeline_label)
	
	timeline_slider = HSlider.new()
	timeline_slider.custom_minimum_size.x = 200
	timeline_slider.min_value = 0.0
	timeline_slider.max_value = 1.0
	timeline_slider.step = 0.01
	timeline_slider.editable = false
	timeline_slider.value_changed.connect(_on_timeline_changed)
	add_child(timeline_slider)
	
	# Time label
	time_label = Label.new()
	time_label.text = "0.0s"
	time_label.custom_minimum_size.x = 50
	add_child(time_label)

# FUNCI√ìN PRINCIPAL: Poblar animaciones (llamada por coordinator)
func populate_animations(model: Node3D):
	print("üé≠ POBLANDO ANIMACIONES (Compatible) - Modelo: %s" % (model.name if model else "NULL"))
	
	# Limpiar estado anterior
	reset_controls()
	
	if not model:
		print("‚ùå Modelo inv√°lido")
		return
	
	# Buscar AnimationPlayer
	current_animation_player = _find_animation_player(model)
	
	if not current_animation_player:
		print("‚ùå No se encontr√≥ AnimationPlayer")
		animations_option.add_item("-- No hay AnimationPlayer --")
		animations_option.disabled = true
		return
	
	print("‚úÖ AnimationPlayer encontrado: %s" % current_animation_player.name)
	
	# Obtener animaciones
	var animation_list = current_animation_player.get_animation_list()
	
	if animation_list.is_empty():
		print("‚ùå No hay animaciones")
		animations_option.add_item("-- No hay animaciones --")
		animations_option.disabled = true
		return
	
	# Configurar loops infinitos
	loop_manager.setup_infinite_loops(current_animation_player)
	print("üîÑ Loops configurados en todas las animaciones")
	
	# Poblar dropdown
	animations_option.clear()
	animations_option.add_item("-- Seleccionar animaci√≥n --")
	
	for anim_name in animation_list:
		animations_option.add_item(anim_name)
		available_animations.append(anim_name)
	
	animations_option.disabled = false
	
	# Conectar se√±al de animaci√≥n finalizada si no est√° conectada
	if not current_animation_player.animation_finished.is_connected(_on_animation_finished):
		current_animation_player.animation_finished.connect(_on_animation_finished)
	
	print("‚úÖ Controles poblados: %d animaciones" % available_animations.size())
	
	# Auto-seleccionar primera animaci√≥n con delay para evitar conflictos
	call_deferred("_auto_select_first_animation")

func _auto_select_first_animation():
	"""Auto-seleccionar primera animaci√≥n despu√©s de poblar"""
	if available_animations.size() > 0:
		print("üéØ Auto-seleccionando primera animaci√≥n: %s" % available_animations[0])
		animations_option.selected = 1  # √çndice 1 = primera animaci√≥n
		_on_animation_selected(1)

# MANEJADOR CR√çTICO: Selecci√≥n de animaci√≥n en dropdown
func _on_animation_selected(index: int):
	print("üñ±Ô∏è ANIMACI√ìN SELECCIONADA - √çndice: %d" % index)
	
	# Validar √≠ndice
	if index <= 0 or index > available_animations.size():
		print("‚ùå √çndice inv√°lido, deshabilitando controles")
		_disable_all_controls()
		return
	
	# Obtener nombre de animaci√≥n seleccionada
	var selected_animation = available_animations[index - 1]
	print("üé≠ Seleccionada: '%s'" % selected_animation)
	
	# Cambiar inmediatamente usando loop manager
	_change_to_animation(selected_animation)
	
	# Configurar timeline para esta animaci√≥n
	if current_animation_player and current_animation_player.has_animation(selected_animation):
		var animation = current_animation_player.get_animation(selected_animation)
		timeline_slider.max_value = animation.length
		timeline_slider.value = 0.0
		time_label.text = "0.0s / %.1fs" % animation.length
	
	# EMITIR SE√ëAL que espera el coordinator
	emit_signal("animation_selected", selected_animation)
	print("üì° Se√±al animation_selected emitida: %s" % selected_animation)

# FUNCI√ìN CR√çTICA: Cambio real de animaci√≥n
func _change_to_animation(animation_name: String):
	print("‚ö° CAMBIANDO A ANIMACI√ìN: %s" % animation_name)
	
	if not current_animation_player or not current_animation_player.has_animation(animation_name):
		print("‚ùå AnimationPlayer inv√°lido o animaci√≥n no existe")
		return
	
	# Usar loop_manager para cambio limpio
	var success = loop_manager.change_animation_clean(current_animation_player, animation_name)
	
	if success:
		current_animation = animation_name
		is_playing = true
		
		# Actualizar UI
		play_button.text = "‚è∏Ô∏è"
		play_button.tooltip_text = "Pausar"
		_enable_controls()
		
		print("‚úÖ Cambio exitoso a: %s" % animation_name)
	else:
		print("‚ùå Fall√≥ el cambio de animaci√≥n")

# MANEJADORES DE BOTONES
func _on_play_pressed():
	print("üéÆ PLAY/PAUSE presionado")
	
	if not current_animation_player or current_animation == "":
		print("‚ùå No hay animaci√≥n activa")
		return
	
	if is_playing:
		# Pausar
		current_animation_player.pause()
		is_playing = false
		play_button.text = "‚ñ∂Ô∏è"
		play_button.tooltip_text = "Continuar"
		emit_signal("pause_requested")
		print("‚è∏Ô∏è Pausado")
	else:
		# Reproducir/Continuar
		current_animation_player.play()
		is_playing = true
		play_button.text = "‚è∏Ô∏è"
		play_button.tooltip_text = "Pausar"
		emit_signal("play_requested", current_animation)
		print("‚ñ∂Ô∏è Reproduciendo")

func _on_pause_pressed():
	print("‚è∏Ô∏è PAUSE presionado")
	_on_play_pressed()  # Reutilizar l√≥gica de play/pause

func _on_stop_pressed():
	print("üõë STOP presionado")
	
	if not current_animation_player:
		return
	
	current_animation_player.stop()
	is_playing = false
	
	# Reset UI
	play_button.text = "‚ñ∂Ô∏è"
	play_button.tooltip_text = "Reproducir"
	timeline_slider.value = 0.0
	
	if current_animation_player.has_animation(current_animation):
		var animation = current_animation_player.get_animation(current_animation)
		time_label.text = "0.0s / %.1fs" % animation.length
	
	emit_signal("stop_requested")
	print("‚èπÔ∏è Detenido")

func _on_timeline_changed(value: float):
	if current_animation_player and current_animation != "":
		current_animation_player.seek(value, true)
		
		if current_animation_player.has_animation(current_animation):
			var animation = current_animation_player.get_animation(current_animation)
			time_label.text = "%.1fs / %.1fs" % [value, animation.length]
		
		emit_signal("timeline_changed", value)

func _on_animation_finished(animation_name: String):
	"""Callback cuando termina una animaci√≥n"""
	if animation_name == current_animation:
		# Como tenemos loop infinito, esto no deber√≠a pasar normalmente
		print("üîÑ Animaci√≥n terminada (reloop): %s" % animation_name)

func _process(delta):
	"""Actualizar timeline durante reproducci√≥n"""
	if is_playing and current_animation_player and current_animation != "":
		if current_animation_player.is_playing():
			var current_time = current_animation_player.current_animation_position
			timeline_slider.value = current_time
			
			if current_animation_player.has_animation(current_animation):
				var animation = current_animation_player.get_animation(current_animation)
				time_label.text = "%.1fs / %.1fs" % [current_time, animation.length]

# FUNCIONES DE CONTROL UI
func _disable_all_controls():
	"""Deshabilitar todos los controles"""
	play_button.disabled = true
	pause_button.disabled = true
	stop_button.disabled = true
	timeline_slider.editable = false

func _enable_controls():
	"""Habilitar controles cuando hay animaci√≥n v√°lida"""
	play_button.disabled = false
	pause_button.disabled = false
	stop_button.disabled = false
	timeline_slider.editable = true

# FUNCIONES DE UTILIDAD
func _find_animation_player(node: Node) -> AnimationPlayer:
	"""Buscar AnimationPlayer recursivamente"""
	if node is AnimationPlayer:
		return node
	
	for child in node.get_children():
		var result = _find_animation_player(child)
		if result:
			return result
	
	return null

func reset_controls():
	"""Reset completo del estado (llamado por coordinator)"""
	print("üîÑ Reseteando controles de animaci√≥n")
	
	# Limpiar estado
	available_animations.clear()
	current_animation = ""
	current_animation_player = null
	is_playing = false
	
	# Reset UI
	animations_option.clear()
	animations_option.add_item("-- No hay animaciones --")
	animations_option.disabled = true
	_disable_all_controls()
	
	timeline_slider.value = 0.0
	time_label.text = "0.0s"

# FUNCIONES P√öBLICAS (para compatibility)
func get_current_animation() -> String:
	"""Obtener animaci√≥n actual"""
	return current_animation

func get_available_animations() -> Array:
	"""Obtener lista de animaciones disponibles"""
	return available_animations.duplicate()

func has_animations() -> bool:
	"""Verificar si hay animaciones disponibles"""
	return not available_animations.is_empty()

func is_animation_playing() -> bool:
	"""Verificar si hay animaci√≥n reproduci√©ndose"""
	return is_playing and current_animation_player and current_animation_player.is_playing()

# FUNCIONES DE DEBUG
func debug_state():
	"""Debug del estado actual"""
	print("\n=== ANIMATION CONTROLS DEBUG ===")
	print("Current animation: '%s'" % current_animation)
	print("Is playing: %s" % is_playing)
	print("Available animations: %s" % str(available_animations))
	print("AnimationPlayer: %s" % (current_animation_player.name if current_animation_player else "NULL"))
	print("Dropdown selected: %d" % animations_option.selected)
	print("Dropdown items: %d" % animations_option.get_item_count())
	
	if current_animation_player:
		print("Player info:")
		print("  - Is playing: %s" % current_animation_player.is_playing())
		print("  - Current: '%s'" % current_animation_player.current_animation)
		print("  - Animation list: %s" % str(current_animation_player.get_animation_list()))
	
	print("================================\n")

# FUNCI√ìN DE TEST MANUAL
func test_change_animation():
	"""Funci√≥n de test para cambiar a segunda animaci√≥n disponible"""
	if available_animations.size() > 1:
		var test_anim = available_animations[1]
		print("üß™ TEST: Cambiando manualmente a: %s" % test_anim)
		animations_option.selected = 2  # √çndice 2 = segunda animaci√≥n
		_on_animation_selected(2)
	else:
		print("üß™ TEST: No hay suficientes animaciones para test")
