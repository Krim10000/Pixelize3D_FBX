# scripts/viewer/viewer_coordinator.gd
# VERSI√ìN CORREGIDA - Conecta todas las se√±ales hu√©rfanas
# Input: Se√±ales de UI
# Output: Coordinaci√≥n completa sin se√±ales perdidas

extends Control

# Referencias a paneles UI
@onready var file_loader_panel = find_child("FileLoaderPanel")
@onready var settings_panel = find_child("SettingsPanel") 
@onready var actions_panel = find_child("ActionsPanel")
@onready var animation_controls_panel = find_child("AnimationControlsPanel")
@onready var model_preview_panel = find_child("ModelPreviewPanel")
@onready var log_panel = find_child("LogPanel")

# Referencias a sistemas core
@onready var fbx_loader = get_node("FBXLoader")
@onready var animation_manager = get_node("AnimationManager")
@onready var sprite_renderer = get_node("SpriteRenderer")

# Datos del sistema
var loaded_base_data: Dictionary = {}
var loaded_animations: Dictionary = {}
var current_combined_model: Node3D = null

# Variables anti-loop
var is_processing_animations: bool = false
var last_animations_processed: Array = []
var processing_start_time: float = 0.0

# ‚úÖ NUEVA: Variable para rastrear cambios de animaci√≥n
var is_changing_animation: bool = false

func _ready():
	print("üéÆ ViewerCoordinator CORREGIDO iniciado")
	await get_tree().process_frame
	_validate_and_connect()
	
	
func _validate_and_connect():
	"""Validar y conectar de forma segura"""
	print("üîç Validando componentes...")
	
	# Validar componentes cr√≠ticos
	if not fbx_loader:
		print("‚ùå FBXLoader no encontrado")
		return
	if not animation_manager:
		print("‚ùå AnimationManager no encontrado") 
		return
	if not file_loader_panel:
		print("‚ùå FileLoaderPanel no encontrado")
		return
	if not log_panel:
		print("‚ùå LogPanel no encontrado")
		return
	
	print("‚úÖ Componentes validados")
	
	# Conectar TODAS las se√±ales
	_connect_all_signals()

func _connect_all_signals():
	"""‚úÖ CORREGIDO: Conectar TODAS las se√±ales incluyendo las hu√©rfanas"""
	print("üîó Conectando TODAS las se√±ales...")
	
	# FileLoaderPanel
	if file_loader_panel:
		file_loader_panel.file_selected.connect(_on_file_selected)
		file_loader_panel.unit_selected.connect(_on_unit_selected)
		file_loader_panel.animations_selected.connect(_on_animations_selected_protected)
		print("‚úÖ FileLoaderPanel conectado")
	
	# ‚úÖ NUEVO: AnimationControlsPanel - CONECTAR SE√ëAL HU√âRFANA
	if animation_controls_panel:
		animation_controls_panel.animation_selected.connect(_on_animation_selected_ui)
		animation_controls_panel.animation_change_requested.connect(_on_animation_change_requested)
		animation_controls_panel.play_requested.connect(_on_play_requested)
		animation_controls_panel.pause_requested.connect(_on_pause_requested)
		animation_controls_panel.stop_requested.connect(_on_stop_requested)
		print("‚úÖ AnimationControlsPanel COMPLETAMENTE conectado")
	
	# ‚úÖ NUEVO: ActionsPanel - CONECTAR SE√ëALES HU√âRFANAS
	if actions_panel:
		actions_panel.preview_requested.connect(_on_preview_requested)
		actions_panel.render_requested.connect(_on_render_requested)
		actions_panel.export_requested.connect(_on_export_requested)
		actions_panel.settings_requested.connect(_on_settings_requested)
		print("‚úÖ ActionsPanel COMPLETAMENTE conectado")
	
	# FBX Loader
	if fbx_loader:
		fbx_loader.model_loaded.connect(_on_model_loaded)
		fbx_loader.load_failed.connect(_on_load_failed)
		print("‚úÖ FBXLoader conectado")
	
	# Animation Manager
	if animation_manager:
		animation_manager.combination_complete.connect(_on_combination_complete_safe)
		animation_manager.combination_failed.connect(_on_combination_failed)
		print("‚úÖ AnimationManager conectado")
	
	print("üîó TODAS las conexiones completadas")

# === MANEJADORES DE ANIMACIONES CORREGIDOS ===

#func _on_animation_change_requested(animation_name: String):
	#"""‚úÖ NUEVO: Manejar cambio de animaci√≥n solicitado desde UI"""
	#print("\nüîÑ === CAMBIO DE ANIMACI√ìN SOLICITADO ===")
	#print("Animaci√≥n solicitada: %s" % animation_name)
	#
	## Prevenir cambios simult√°neos
	#if is_changing_animation:
		#print("‚ö†Ô∏è Ya hay un cambio en progreso")
		#return
	#
	#is_changing_animation = true
	#log_panel.add_log("üîÑ Cambiando a: " + animation_name)
	#
	## Verificar si tenemos el modelo combinado
	#if not current_combined_model:
		#print("‚ùå No hay modelo combinado")
		#_finish_animation_change(false, animation_name)
		#return
	#
	## Buscar el AnimationPlayer en el modelo actual
	#var anim_player = _find_animation_player(current_combined_model)
	#if not anim_player:
		#print("‚ùå No se encontr√≥ AnimationPlayer")
		#_finish_animation_change(false, animation_name)
		#return
	#
	## Verificar que la animaci√≥n existe
	#if not anim_player.has_animation(animation_name):
		#print("‚ùå La animaci√≥n '%s' no existe" % animation_name)
		#
		## Intentar con el nombre limpio (sin extensi√≥n)
		#var clean_name = animation_name.get_basename()
		#if anim_player.has_animation(clean_name):
			#animation_name = clean_name
			#print("‚úÖ Usando nombre limpio: %s" % clean_name)
		#else:
			## Buscar en la lista de animaciones
			#var found = false
			#for anim in anim_player.get_animation_list():
				#if animation_name in anim or anim in animation_name:
					#animation_name = anim
					#found = true
					#print("‚úÖ Animaci√≥n encontrada como: %s" % anim)
					#break
			#
			#if not found:
				#print("‚ùå No se pudo encontrar la animaci√≥n")
				#_finish_animation_change(false, animation_name)
				#return
	#
	## Cambiar la animaci√≥n directamente
	#print("‚ñ∂Ô∏è Cambiando animaci√≥n a: %s" % animation_name)
	#
	## Detener animaci√≥n actual si est√° reproduciendo
	#if anim_player.is_playing():
		#anim_player.stop()
	#
	## Configurar loop para la nueva animaci√≥n
	#var anim_lib = anim_player.get_animation_library("")
	#if anim_lib and anim_lib.has_animation(animation_name):
		#var animation = anim_lib.get_animation(animation_name)
		#animation.loop_mode = Animation.LOOP_LINEAR
		#print("üîÑ Loop configurado para: %s" % animation_name)
	#
	## Reproducir nueva animaci√≥n
	#anim_player.play(animation_name)
	#
	## Notificar al panel de controles que el cambio se complet√≥
	#if animation_controls_panel and animation_controls_panel.has_method("on_model_recombined"):
		## Simular que se recombin√≥ el modelo (aunque solo cambiamos la animaci√≥n)
		#animation_controls_panel.on_model_recombined(current_combined_model, animation_name)
	#
	## Actualizar preview si est√° activo
	#if model_preview_panel and model_preview_panel.has_method("play_animation"):
		#model_preview_panel.play_animation(animation_name)
	#
	#log_panel.add_log("‚úÖ Animaci√≥n cambiada: " + animation_name)
	#_finish_animation_change(true, animation_name)
	#
	#print("=== FIN CAMBIO DE ANIMACI√ìN ===\n")

func _finish_animation_change(success: bool, animation_name: String):
	"""Finalizar proceso de cambio de animaci√≥n"""
	is_changing_animation = false
	
	if not success:
		log_panel.add_log("‚ùå Error al cambiar animaci√≥n: " + animation_name)
		
		# Notificar error al panel
		if animation_controls_panel and animation_controls_panel.has_method("_reset_ui_on_error"):
			animation_controls_panel._reset_ui_on_error("No se pudo cambiar la animaci√≥n")

# === MANEJADORES DE ACCIONES ===

func _on_preview_requested():
	"""‚úÖ NUEVO: Manejar solicitud de preview"""
	print("üé¨ Preview solicitado")
	log_panel.add_log("üé¨ Activando preview...")
	
	if not current_combined_model:
		log_panel.add_log("‚ùå No hay modelo para preview")
		return
	
	# El preview ya deber√≠a estar activo, solo confirmamos
	if model_preview_panel:
		model_preview_panel.set_model(current_combined_model)
		model_preview_panel.show()
		log_panel.add_log("‚úÖ Preview activo")

func _on_render_requested():
	"""‚úÖ NUEVO: Manejar solicitud de renderizado"""
	print("üé® Renderizado solicitado")
	log_panel.add_log("üé® Iniciando renderizado...")
	
	if not current_combined_model:
		log_panel.add_log("‚ùå No hay modelo para renderizar")
		actions_panel.show_error("No hay modelo cargado")
		return
	
	# Delegar al sprite_renderer
	if sprite_renderer and sprite_renderer.has_method("render_current_animation"):
		actions_panel.start_processing("Renderizando sprites...")
		
		# Obtener configuraci√≥n de settings_panel si existe
		var settings = {}
		if settings_panel and settings_panel.has_method("get_current_settings"):
			settings = settings_panel.get_current_settings()
		
		sprite_renderer.setup_model(current_combined_model)
		sprite_renderer.render_current_animation(settings)
	else:
		log_panel.add_log("‚ùå SpriteRenderer no disponible")

func _on_export_requested():
	"""‚úÖ NUEVO: Manejar solicitud de exportaci√≥n"""
	print("üíæ Exportaci√≥n solicitada")
	log_panel.add_log("üíæ Preparando exportaci√≥n...")
	
	# Aqu√≠ ir√≠a la l√≥gica de exportaci√≥n
	# Por ahora solo mostramos mensaje
	actions_panel.show_info("Funci√≥n de exportaci√≥n en desarrollo")
	log_panel.add_log("‚ÑπÔ∏è Exportaci√≥n no implementada a√∫n")

func _on_settings_requested():
	"""‚úÖ NUEVO: Manejar solicitud de configuraci√≥n"""
	print("‚öôÔ∏è Configuraci√≥n solicitada")
	
	# Mostrar/ocultar panel de configuraci√≥n
	if settings_panel:
		settings_panel.visible = not settings_panel.visible
		log_panel.add_log("‚öôÔ∏è Panel de configuraci√≥n: " + ("visible" if settings_panel.visible else "oculto"))

# === MANEJADORES DE CONTROLES DE ANIMACI√ìN ===

func _on_animation_selected_ui(animation_name: String):
	"""Manejar selecci√≥n de animaci√≥n desde UI (informaci√≥n)"""
	print("üìç Animaci√≥n seleccionada en UI: %s" % animation_name)
	# Esta se√±al es solo informativa, el cambio real viene con animation_change_requested

func _on_play_requested(animation_name: String):
	"""Manejar solicitud de reproducci√≥n"""
	print("‚ñ∂Ô∏è Reproducci√≥n solicitada: %s" % animation_name)
	
	if model_preview_panel and model_preview_panel.has_method("play_animation"):
		model_preview_panel.play_animation(animation_name)

func _on_pause_requested():
	"""Manejar solicitud de pausa"""
	print("‚è∏Ô∏è Pausa solicitada")
	
	if model_preview_panel and model_preview_panel.has_method("pause_animation"):
		model_preview_panel.pause_animation()

func _on_stop_requested():
	"""Manejar solicitud de detenci√≥n"""
	print("‚èπÔ∏è Detenci√≥n solicitada")
	
	if model_preview_panel and model_preview_panel.has_method("stop_animation"):
		model_preview_panel.stop_animation()

# === FUNCIONES AUXILIARES ===

func _find_animation_player(node: Node) -> AnimationPlayer:
	"""Buscar AnimationPlayer recursivamente"""
	if node is AnimationPlayer:
		return node
	
	for child in node.get_children():
		var result = _find_animation_player(child)
		if result:
			return result
	
	return null

# === MANEJADORES EXISTENTES (sin cambios) ===

func _on_file_selected(file_path: String):
	"""Manejar selecci√≥n de archivo"""
	print("üìÅ Archivo seleccionado: %s" % file_path.get_file())
	log_panel.add_log("üìÅ Cargando: " + file_path.get_file())
	
	var is_base = "base" in file_path.get_file().to_lower()
	
	if is_base:
		print("üèóÔ∏è Cargando como BASE")
		fbx_loader.load_base_model(file_path)
	else:
		print("üé≠ Cargando como ANIMACI√ìN")
		fbx_loader.load_animation_fbx(file_path)

func _on_unit_selected(unit_data: Dictionary):
	"""Manejar selecci√≥n de unidad"""
	print("üì¶ Unidad seleccionada: %s" % unit_data.get("name", "Unknown"))
	log_panel.add_log("üì¶ Unidad: " + str(unit_data.get("name", "Unknown")))
	
	if file_loader_panel and file_loader_panel.has_method("populate_unit_files"):
		file_loader_panel.populate_unit_files(unit_data)

func _on_animations_selected_protected(animation_files: Array):
	"""Manejar selecci√≥n de animaciones con protecci√≥n anti-loops"""
	print("\nüõë === ANIMATIONS SELECTED PROTECTED ===")
	print("Archivos recibidos: %s" % str(animation_files))

	# Protecciones existentes
	if is_processing_animations:
		var elapsed = Time.get_ticks_msec() / 1000.0 - processing_start_time
		print("üõë YA PROCESANDO ANIMACIONES (%.1fs transcurrido)" % elapsed)
		if elapsed < 10:
			print("üõë IGNORANDO - muy pronto")
			return
		else:
			print("‚ö†Ô∏è Timeout alcanzado, continuando...")

	if _arrays_equal(animation_files, last_animations_processed):
		print("üõë ANIMACIONES ID√âNTICAS - ignorando")
		return

	if animation_files.is_empty():
		print("üõë ARRAY VAC√çO - ignorando")
		return

	if not file_loader_panel or not file_loader_panel.has_method("get_current_unit_data"):
		print("üõë NO HAY UNIT DATA - ignorando")
		return

	var unit_data = file_loader_panel.get_current_unit_data()
	if unit_data.is_empty() or not unit_data.has("path"):
		print("üõë UNIT DATA INV√ÅLIDO - ignorando")
		return

	# Marcar como procesando
	is_processing_animations = true
	processing_start_time = Time.get_ticks_msec() / 1000.0
	last_animations_processed = animation_files.duplicate()

	print("üîí PROCESANDO ANIMACIONES - BLOQUEADO por 10 segundos")
	log_panel.add_log("üé¨ Cargando %d animaciones..." % animation_files.size())

	# Cargar una por una
	for i in range(animation_files.size()):
		var anim_file = animation_files[i]
		var full_path = unit_data.path + "/" + anim_file

		print("üì• [%d/%d] Cargando: %s" % [i+1, animation_files.size(), anim_file])
		log_panel.add_log("üì• [%d/%d] %s" % [i+1, animation_files.size(), anim_file])

		fbx_loader.load_animation_fbx(full_path)

		if i < animation_files.size() - 1:
			await get_tree().create_timer(1.0).timeout

	# Fin de carga
	await get_tree().create_timer(2.0).timeout
	is_processing_animations = false
	print("üîì PROCESAMIENTO DE ANIMACIONES DESBLOQUEADO")

	# Actualizar paneles
	#animation_controls_panel.update_animations_list(animation_files)

	var last_animation_path = animation_files[-1]
	var last_animation_name = last_animation_path.get_file().get_basename()

	#animation_controls_panel.select_animation_by_name(last_animation_name)
	#model_preview_panel.play_animation(last_animation_name)
	if loaded_base_data and loaded_animations.size() > 0:
		print("LLAMANDO A _combine_all_animations ")

		_combine_all_animations()  # <-- ESTA ES LA L√çNEA CR√çTICA
	print("‚úÖ Animaci√≥n aplicada: " + last_animation_name)
	print("=== FIN ANIMATIONS SELECTED ===\n")

func _on_model_loaded(model_data: Dictionary):
	"""Manejar modelo cargado"""
	print("üì¶ Modelo cargado: %s (%s)" % [model_data.get("name", "Unknown"), model_data.get("type", "Unknown")])
	
	if model_data.type == "base":
		loaded_base_data = model_data
		log_panel.add_log("‚úÖ Base: " + str(model_data.get("name", "Unknown")))
		
		if actions_panel:
			actions_panel.set_status("Base cargada - selecciona animaciones")
			
		_try_auto_combine()
	else:
		var anim_name = model_data.get("name", "Unknown")
		loaded_animations[anim_name] = model_data
		log_panel.add_log("‚úÖ Animaci√≥n: " + anim_name)
		
		_try_auto_combine()

func _on_load_failed(error_message: String):
	"""Manejar error de carga"""
	print("‚ùå Error de carga: %s" % error_message)
	log_panel.add_log("‚ùå Error: " + error_message)
	
	is_processing_animations = false

func _try_auto_combine():
	"""Intentar combinar autom√°ticamente cuando tengamos base + animaci√≥n"""
	if loaded_base_data.is_empty() or loaded_animations.is_empty():
		return
	
	if current_combined_model != null:
		return
	
	print("üîÑ Auto-combinando modelo...")
	log_panel.add_log("üîÑ Combinando modelo...")
	
	var first_anim_name = loaded_animations.keys()[0]
	var first_anim_data = loaded_animations[first_anim_name]
	
	var combined = animation_manager.combine_base_with_animation(loaded_base_data, first_anim_data)
	if combined:
		_on_combination_complete_safe(combined)

func _on_combination_complete_safe(combined_model: Node3D):
	"""Manejar combinaci√≥n exitosa de forma segura"""
	if not combined_model:
		print("‚ùå Modelo combinado es null")
		return
	
	print("‚úÖ Combinaci√≥n exitosa: %s" % combined_model.name)
	log_panel.add_log("‚úÖ Modelo combinado listo")
	
	current_combined_model = combined_model
	
	# Actualizar preview
	if model_preview_panel and model_preview_panel.has_method("set_model"):
		model_preview_panel.set_model(current_combined_model)
		print("‚úÖ Preview actualizado")
	
	# Poblar controles
	_safe_populate_animation_controls()
	
	# Habilitar botones de acci√≥n
	if actions_panel:
		actions_panel.enable_preview_button()
		actions_panel.enable_render_button()
		actions_panel.set_status("‚úÖ Modelo listo para renderizar")

func _safe_populate_animation_controls():
	"""Poblar controles de animaci√≥n de forma segura"""
	if not current_combined_model:
		print("‚ùå No hay modelo combinado para poblar controles")
		return
	
	if not animation_controls_panel:
		print("‚ùå No hay animation_controls_panel")
		return
	
	if not animation_controls_panel.has_method("populate_animations"):
		print("‚ùå populate_animations no disponible")
		return
	
	print("üéÆ Poblando controles de animaci√≥n")
	log_panel.add_log("üéÆ Controles de animaci√≥n listos")
	animation_controls_panel.populate_animations(current_combined_model)
	print("‚úÖ Animation controls poblados exitosamente")

func _on_combination_failed(error: String):
	"""Manejar error de combinaci√≥n"""
	print("‚ùå Error combinaci√≥n: %s" % error)
	log_panel.add_log("‚ùå Error combinaci√≥n: " + error)

func _arrays_equal(a: Array, b: Array) -> bool:
	"""Comparar arrays"""
	if a.size() != b.size():
		return false
	for i in range(a.size()):
		if a[i] != b[i]:
			return false
	return true

# === FUNCIONES P√öBLICAS ===

func combine_and_view():
	"""Combinar y preparar vista manualmente"""
	print("üîÑ === COMBINACI√ìN MANUAL ===")
	log_panel.add_log("üîÑ Combinando y preparando vista...")
	
	if loaded_base_data.is_empty():
		log_panel.add_log("‚ùå No hay modelo base cargado")
		return false
	
	if loaded_animations.is_empty():
		log_panel.add_log("‚ùå No hay animaciones cargadas")
		return false
	
	var first_anim_name = loaded_animations.keys()[0]
	var first_anim_data = loaded_animations[first_anim_name]
	
	print("üîÑ Combinando: base + %s" % first_anim_name)
	log_panel.add_log("üîÑ Combinando con: " + first_anim_name)
	
	var combined = animation_manager.combine_base_with_animation(loaded_base_data, first_anim_data)
	if combined:
		current_combined_model = combined
		print("‚úÖ Combinaci√≥n exitosa")
		log_panel.add_log("‚úÖ Combinaci√≥n exitosa")
		
		if model_preview_panel:
			model_preview_panel.set_model(current_combined_model)
		
		_safe_populate_animation_controls()
		
		#if actions_panel:
			#actions_panel.enable_preview_button()
			#actions_panel.enable_render_button()
		
		log_panel.add_log("üéÆ ¬°Listo! Usa los controles")
		return true
	else:
		log_panel.add_log("‚ùå Error en combinaci√≥n")
		return false

func get_current_state() -> Dictionary:
	"""Estado actual del sistema"""
	return {
		"base_loaded": not loaded_base_data.is_empty(),
		"animations_count": loaded_animations.size(),
		"combined_ready": current_combined_model != null,
		"processing": is_processing_animations,
		"changing_animation": is_changing_animation
	}

func debug_state():
	"""Debug detallado del estado"""
	print("\nüéÆ === COORDINATOR DEBUG ===")
	var state = get_current_state()
	print("üìä ESTADO:")
	print("  Base cargada: %s" % state.base_loaded)
	print("  Animaciones: %d" % state.animations_count)
	print("  Modelo combinado: %s" % state.combined_ready)
	print("  Procesando: %s" % state.processing)
	print("  Cambiando animaci√≥n: %s" % state.changing_animation)
	
	if animation_controls_panel:
		print("\nüéÆ ANIMATION CONTROLS:")
		if animation_controls_panel.has_method("debug_state"):
			animation_controls_panel.debug_state()
	
	print("===========================\n")


# Correcciones para el ViewerCoordinator para manejar m√∫ltiples animaciones
# Agrega estas funciones mejoradas a viewer_coordinator.gd:

# Variable adicional para rastrear si necesitamos recombinar
var pending_animations_for_combination: Array = []

#func _on_animations_selected_protected(animation_files: Array):
	#"""Manejar selecci√≥n de animaciones - MEJORADO para m√∫ltiples"""
	#print("\nüõë === ANIMATIONS SELECTED PROTECTED ===")
	#print("Archivos recibidos: %s" % str(animation_files))
#
	## Protecciones existentes...
	#if is_processing_animations:
		#var elapsed = Time.get_ticks_msec() / 1000.0 - processing_start_time
		#print("üõë YA PROCESANDO ANIMACIONES (%.1fs transcurrido)" % elapsed)
		#if elapsed < 10:
			#print("üõë IGNORANDO - muy pronto")
			#return
		#else:
			#print("‚ö†Ô∏è Timeout alcanzado, continuando...")
#
	#if _arrays_equal(animation_files, last_animations_processed):
		#print("üõë ANIMACIONES ID√âNTICAS - ignorando")
		#return
#
	#if animation_files.is_empty():
		#print("üõë ARRAY VAC√çO - ignorando")
		#return
#
	#var unit_data = file_loader_panel.get_current_unit_data()
	#if unit_data.is_empty() or not unit_data.has("path"):
		#print("üõë UNIT DATA INV√ÅLIDO - ignorando")
		#return
#
	## Marcar como procesando
	#is_processing_animations = true
	#processing_start_time = Time.get_ticks_msec() / 1000.0
	#last_animations_processed = animation_files.duplicate()
#
	#print("üîí PROCESANDO ANIMACIONES - BLOQUEADO")
	#log_panel.add_log("üé¨ Cargando %d animaciones..." % animation_files.size())
#
	## ‚úÖ NUEVO: Limpiar animaciones cargadas para recargar todas
	#loaded_animations.clear()
	#pending_animations_for_combination = animation_files.duplicate()
#
	## Cargar TODAS las animaciones
	#for i in range(animation_files.size()):
		#var anim_file = animation_files[i]
		#var full_path = unit_data.path + "/" + anim_file
#
		#print("üì• [%d/%d] Cargando: %s" % [i+1, animation_files.size(), anim_file])
		#log_panel.add_log("üì• [%d/%d] %s" % [i+1, animation_files.size(), anim_file])
#
		#fbx_loader.load_animation_fbx(full_path)
#
		#if i < animation_files.size() - 1:
			#await get_tree().create_timer(0.5).timeout
#
	## ‚úÖ NUEVO: Esperar y luego combinar TODO
	#await get_tree().create_timer(1.0).timeout
	#
	## Combinar todas las animaciones
	#if loaded_base_data and loaded_animations.size() > 0:
		#_combine_all_animations()
	#
	#is_processing_animations = false
	#print("üîì PROCESAMIENTO DESBLOQUEADO")
	#print("=== FIN ANIMATIONS SELECTED ===\n")

func _combine_all_animations():
	"""‚úÖ NUEVA FUNCI√ìN: Combinar TODAS las animaciones en un solo modelo"""
	print("\nüîÑ === COMBINANDO TODAS LAS ANIMACIONES ===")
	print("Base disponible: %s" % loaded_base_data.get("name", "Unknown"))
	print("Animaciones disponibles: %d" % loaded_animations.size())
	
	# Usar la primera animaci√≥n como base para la combinaci√≥n
	var first_anim_name = loaded_animations.keys()[-1]
	var first_anim_data = loaded_animations[first_anim_name]
	
	print("üîÑ Combinando base con primera animaci√≥n: %s" % first_anim_name)
	
	# Combinar base + primera animaci√≥n
	var combined = animation_manager.combine_base_with_animation(loaded_base_data, first_anim_data)
	#var combined = animation_manager.combine_base_with_multiple_animations(loaded_base_data, first_anim_data)

	#combine_base_with_multiple_animations
	if not combined:
		print("‚ùå Error en combinaci√≥n inicial")
		return
	
	# ‚úÖ CR√çTICO: Agregar las dem√°s animaciones al modelo combinado
	#if loaded_animations.size() > 1:
		#print("üìã Agregando %d animaciones adicionales..." % (loaded_animations.size() - 1))
		#
		#var combined_anim_player = _find_animation_player(combined)
		#if combined_anim_player:
			## Obtener la librer√≠a de animaciones
			#var anim_lib = combined_anim_player.get_animation_library("")
			#if not anim_lib:
				#print("‚ùå No se encontr√≥ librer√≠a de animaciones")
				#return
			#
			## Agregar cada animaci√≥n adicional
			#var added_count = 0
			#for anim_name in loaded_animations:
				#if anim_name == first_anim_name:
					#continue  # Skip la primera que ya est√°
				#
				#var anim_data = loaded_animations[anim_name]
				#if anim_data.has("model"):
					#var anim_model = anim_data["model"]
					#var source_player = _find_animation_player(anim_model)
					#
					#if source_player:
						#var source_anims = source_player.get_animation_list()
						#for source_anim_name in source_anims:
							## Copiar la animaci√≥n
							#var source_lib = source_player.get_animation_library("")
							#if source_lib and source_lib.has_animation(source_anim_name):
								#var anim_to_copy = source_lib.get_animation(source_anim_name)
								#
								## Usar el nombre limpio de la animaci√≥n
								#var clean_name = anim_name
								#if source_anim_name != "mixamo_com" and source_anim_name != "":
									#clean_name = source_anim_name
								#
								#print("  + Agregando: %s" % clean_name)
								#
								## Clonar y agregar la animaci√≥n
								#var anim_copy = anim_to_copy.duplicate()
								#anim_lib.add_animation(clean_name, anim_copy)
								#added_count += 1
				#
			#print("‚úÖ Agregadas %d animaciones adicionales" % added_count)
			#
			## Configurar loops para todas
			#var all_anims = combined_anim_player.get_animation_list()
			#for anim in all_anims:
				#if anim_lib.has_animation(anim):
					#var animation = anim_lib.get_animation(anim)
					#animation.loop_mode = Animation.LOOP_LINEAR
			#
			#print("üìã Total de animaciones en el modelo: %d" % all_anims.size())
			#print("  Animaciones: %s" % str(all_anims))
	#
	# Guardar el modelo combinado
	current_combined_model = combined
	
	# Actualizar UI
	_on_combination_complete_safe(combined)
	
	# Actualizar lista de animaciones en el panel
	if animation_controls_panel:
		# Crear lista de nombres de archivo para el panel
		var file_names = []
		for anim_name in loaded_animations.keys():
			file_names.append(anim_name + ".fbx")
		
		animation_controls_panel.update_animations_list(file_names)
		
		# Seleccionar la primera
		if file_names.size() > 0:
			animation_controls_panel.select_animation_by_name(first_anim_name)
	
	print("=== FIN COMBINACI√ìN M√öLTIPLE ===\n")

func _on_animation_change_requested(animation_name: String):
	"""‚úÖ MEJORADO: Manejar cambio con b√∫squeda m√°s inteligente"""
	print("\nüîÑ === CAMBIO DE ANIMACI√ìN SOLICITADO ===")
	print("Animaci√≥n solicitada: %s" % animation_name)
	
	if is_changing_animation:
		print("‚ö†Ô∏è Ya hay un cambio en progreso")
		return
	
	is_changing_animation = true
	log_panel.add_log("üîÑ Cambiando a: " + animation_name)
	
	if not current_combined_model:
		print("‚ùå No hay modelo combinado")
		_finish_animation_change(false, animation_name)
		return
	
	var anim_player = _find_animation_player(current_combined_model)
	if not anim_player:
		print("‚ùå No se encontr√≥ AnimationPlayer")
		_finish_animation_change(false, animation_name)
		return
	
	# ‚úÖ MEJORADO: B√∫squeda m√°s inteligente de animaciones
	var found_animation = ""
	var clean_name = animation_name.get_basename()  # Quitar .fbx
	
	print("üîç Buscando animaci√≥n: '%s' (limpio: '%s')" % [animation_name, clean_name])
	print("üìã Animaciones disponibles: %s" % str(anim_player.get_animation_list()))
	
	# Buscar coincidencia exacta primero
	if anim_player.has_animation(animation_name):
		found_animation = animation_name
	elif anim_player.has_animation(clean_name):
		found_animation = clean_name
	else:
		# Buscar en loaded_animations para obtener el nombre correcto
		for loaded_name in loaded_animations.keys():
			if loaded_name == clean_name or loaded_name == animation_name:
				# Este es el archivo que queremos, buscar su animaci√≥n
				if anim_player.has_animation(loaded_name):
					found_animation = loaded_name
					break
				# Tambi√©n probar con el nombre del archivo sin extensi√≥n
				var file_base = loaded_name.get_basename()
				if anim_player.has_animation(file_base):
					found_animation = file_base
					break
		
		# Si a√∫n no encontramos, buscar parcialmente
		if found_animation == "":
			for anim in anim_player.get_animation_list():
				if clean_name in anim or anim in clean_name:
					found_animation = anim
					break
	
	if found_animation == "":
		print("‚ùå No se encontr√≥ la animaci√≥n '%s'" % animation_name)
		print("   Animaciones disponibles: %s" % str(anim_player.get_animation_list()))
		_finish_animation_change(false, animation_name)
		return
	
	print("‚úÖ Animaci√≥n encontrada: '%s'" % found_animation)
	
	# Cambiar la animaci√≥n
	if anim_player.is_playing():
		anim_player.stop()
	
	# Configurar loop
	var anim_lib = anim_player.get_animation_library("")
	if anim_lib and anim_lib.has_animation(found_animation):
		var animation = anim_lib.get_animation(found_animation)
		animation.loop_mode = Animation.LOOP_LINEAR
	
	# Reproducir
	anim_player.play(found_animation)
	
	# Notificar al panel
	if animation_controls_panel and animation_controls_panel.has_method("on_model_recombined"):
		animation_controls_panel.on_model_recombined(current_combined_model, found_animation)
	
	# Actualizar preview
	if model_preview_panel and model_preview_panel.has_method("play_animation"):
		model_preview_panel.play_animation(found_animation)
	
	log_panel.add_log("‚úÖ Animaci√≥n cambiada: " + found_animation)
	_finish_animation_change(true, found_animation)
	
	print("=== FIN CAMBIO DE ANIMACI√ìN ===\n")


# Parte cr√≠tica de _on_animation_change_requested en viewer_coordinator.gd
# Esta es la b√∫squeda mejorada que encuentra animaciones con nombres problem√°ticos:

	# ‚úÖ B√öSQUEDA INTELIGENTE DE ANIMACIONES
  # Quitar .fbx si existe
	
	print("üîç Buscando animaci√≥n: '%s' (limpio: '%s')" % [animation_name, clean_name])
	print("üìã Animaciones disponibles: %s" % str(anim_player.get_animation_list()))
	
	# 1. Buscar coincidencia exacta
	if anim_player.has_animation(animation_name):
		found_animation = animation_name
	elif anim_player.has_animation(clean_name):
		found_animation = clean_name
	else:
		# 2. Buscar en loaded_animations para mapear nombres
		for loaded_name in loaded_animations.keys():
			# Ejemplo: "Zombie Death(1)" == "Zombie Death(1).fbx".get_basename()
			if loaded_name == clean_name or loaded_name == animation_name:
				if anim_player.has_animation(loaded_name):
					found_animation = loaded_name
					break
		
		# 3. Si a√∫n no encontramos, buscar parcialmente
		if found_animation == "":
			# Quitar caracteres problem√°ticos para comparaci√≥n
			var search_name = clean_name.replace("(", "").replace(")", "").strip_edges()
			
			for anim in anim_player.get_animation_list():
				var anim_clean = anim.replace("(", "").replace(")", "").strip_edges()
				
				# Comparaci√≥n flexible
				if search_name in anim_clean or anim_clean in search_name:
					found_animation = anim
					print("   ‚úÖ Encontrada por b√∫squeda parcial: '%s'" % anim)
					break
	
	if found_animation == "":
		print("‚ùå No se encontr√≥ la animaci√≥n '%s'" % animation_name)
		print("   Disponibles: %s" % str(anim_player.get_animation_list()))
		_finish_animation_change(false, animation_name)
		return
	
	print("‚úÖ Animaci√≥n encontrada: '%s'" % found_animation)


# scripts/viewer/viewer_coordinator.gd
# INTEGRACI√ìN: Agregar esta llamada en la funci√≥n force_reset() existente

func force_reset():
	"""Reset completo del coordinator"""
	print("üö® FORCE RESET COORDINATOR")
	
	# Reset flags
	is_processing_animations = false
	last_animations_processed.clear()
	processing_start_time = 0.0
	
	# Clear data
	loaded_base_data.clear()
	loaded_animations.clear()
	
	if current_combined_model:
		current_combined_model.queue_free()
		current_combined_model = null
	
	# ‚úÖ NUEVO: Reset del sistema de animaciones del AnimationManager
	if animation_manager and animation_manager.has_method("reset_animation_system"):
		animation_manager.reset_animation_system()
		print("üîÑ Sistema de animaciones reseteado")
	
	# Reset panels
	if file_loader_panel and file_loader_panel.has_method("_emergency_reset"):
		file_loader_panel._emergency_reset()
	
	if animation_controls_panel and animation_controls_panel.has_method("reset_controls"):
		animation_controls_panel.reset_controls()
	
	print("‚úÖ COORDINATOR RESET COMPLETO")

# ‚úÖ FUNCI√ìN NUEVA: Reset p√∫blico f√°cil de usar desde consola
func full_system_reset():
	"""Reset completo del sistema - funci√≥n p√∫blica para usar desde consola"""
	print("üî• === FULL SYSTEM RESET SOLICITADO ===")
	force_reset()
	print("‚úÖ Full system reset completado")
	print("üí° Ahora puedes cargar nuevas animaciones desde cero")

# ‚úÖ FUNCI√ìN NUEVA: Debug del estado del AnimationManager
func debug_animation_manager():
	"""Debug espec√≠fico del AnimationManager"""
	print("\nüé≠ === ANIMATION MANAGER DEBUG ===")
	if not animation_manager:
		print("‚ùå AnimationManager no encontrado")
		return
	
	# Verificar si tiene el AnimationPlayer en construcci√≥n
	if animation_manager.has_method("get_current_building_animation_player"):
		var building_player = animation_manager.get_current_building_animation_player()
		if building_player:
			print("üîß AnimationPlayer en construcci√≥n: %s" % building_player.name)
			print("   Animaciones: %d" % building_player.get_animation_list().size())
			for anim_name in building_player.get_animation_list():
				print("     - %s" % anim_name)
		else:
			print("‚úÖ No hay AnimationPlayer en construcci√≥n")
	
	# Verificar cach√©s
	print("üì¶ Estado de cach√©s:")
	print("   Base meshes cache: %d items" % (animation_manager.base_meshes_cache.size() if animation_manager.has_method("get") else 0))
	print("   Animations metadata cache: %d items" % (animation_manager.animations_metadata_cache.size() if animation_manager.has_method("get") else 0))
	
	print("=========================================\n")
